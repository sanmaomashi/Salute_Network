### 4. 端口

#### 4.1 什么是端口

端口就好一个房子的门，是出入这间房子的必经之路。

如果一个程序需要收发网络数据，那么就需要有这样的端口

在linux系统中，端口可以有65536（2的16次方）个之多！

既然有这么多，操作系统为了统一管理，所以进行了编号，这就是`端口号`

#### 4.2 端口号

端口是通过端口号来标记的，端口号只有整数，范围是从0到65535

注意：端口数不一样的*nix系统不一样，还可以手动修改

#### 4.3 端口是怎样分配的

端口号不是随意使用的，而是按照一定的规定进行分配。

端口的分类标准有好几种，我们这里不做详细讲解，只介绍一下知名端口和动态端口

**知名端口（Well Known Ports）**

知名端口是众所周知的端口号，范围从0到1023

```text
80端口分配给HTTP服务
21端口分配给FTP服务
```

可以理解为，一些常用的功能使用的号码是估计的，好比 电话号码110、10086、10010一样

一般情况下，如果一个程序需要使用知名端口的需要有root权限

**动态端口（Dynamic Ports）**

动态端口的范围是从1024到65535

之所以称为动态端口，是因为它一般不固定分配某种服务，而是动态分配。

动态分配是指当一个系统程序或应用程序程序需要网络通信时，它向主机申请一个端口，主机从可用的端口号中分配一个供它使用。

当这个程序关闭时，同时也就释放了所占用的端口号

**怎样查看端口 ？**

- 用“netstat －an”查看端口状态
- lsof -i [tcp/udp]:2425

#### 4.4 小总结

端口有什么用呢 ？ 我们知道，一台拥有IP地址的主机可以提供许多服务，比如HTTP（万维网服务）、FTP（文件传输）、SMTP（电子邮件）等，这些服务完全可以通过1个IP地址来实现。那么，主机是怎样区分不同的网络服务呢？显然不能只靠IP地址，因为IP地址与网络服务的关系是一对多的关系。实际上是通过“IP地址+端口号”来区分不同的服务的。 需要注意的是，端口并不是一一对应的。比如你的电脑作为客户机访问一台WWW服务器时，WWW服务器使用“80”端口与你的电脑通信，但你的电脑则可能使用“3457”这样的端口。

## 二、socket简介

套接字

### 1. 不同电脑上的进程之间如何通信

首要解决的问题是如何唯一标识一个进程，否则通信无从谈起！

在1台电脑上可以通过进程号（PID）来唯一标识一个进程，但是在网络中这是行不通的。

其实TCP/IP协议族已经帮我们解决了这个问题，网络层的“ip地址”可以唯一标识网络中的主机，而传输层的“协议+端口”可以唯一标识主机中的应用进程（进程）。

这样利用ip地址，协议，端口就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互

**注意：**

- 所谓`进程`指的是：运行的程序以及运行时用到的资源这个整体称之为进程（在讲解多任务编程时进行详细讲解）
- 所谓`进程间通信`指的是：运行的程序之间的数据共享

### 2. 什么是socket

socket(简称 `套接字`) 是进程间通信的一种方式，它与其他进程间通信的一个主要不同是：

它能实现不同主机间的进程间通信，我们网络上各种各样的服务大多都是基于 Socket 来完成通信的

例如我们每天浏览网页、QQ 聊天、收发 email 等等

### 3. 创建socket

在 Python 中 使用socket 模块的函数 socket 就可以完成：

```python
import socket
socket.socket(AddressFamily, Type)
```

**说明：**

函数 socket.socket 创建一个 socket，该函数带有两个参数：

- Address Family：可以选择 AF_INET（用于 Internet 进程间通信） 或者 AF_UNIX（用于同一台机器进程间通信）,实际工作中常用AF_INET
- Type：套接字类型，可以是 SOCK_STREAM（流式套接字，主要用于 TCP 协议）或者 SOCK_DGRAM（数据报套接字，主要用于 UDP 协议）

创建一个tcp socket（tcp套接字）

```python
import socket

# 创建tcp的套接字
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# ...这里是使用套接字的功能（省略）...

# 不用的时候，关闭套接字
s.close()
```

创建一个udp socket（udp套接字）

```python
import socket

# 创建udp的套接字
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# ...这里是使用套接字的功能（省略）...

# 不用的时候，关闭套接字
s.close()
```

**说明**

套接字使用流程与文件的使用流程很类似
1. 创建套接字
2. 使用套接字收/发数据
3. 关闭套接字

## 三、UDP网络

### 1. udp网络程序-发送数据

创建一个基于udp的网络程序流程很简单，具体步骤如下：

1. 创建客户端套接字
2. 发送/接收数据
3. 关闭套接字

代码如下：

```python
#coding=utf-8

from socket import *

# 1. 创建udp套接字
udp_socket = socket(AF_INET, SOCK_DGRAM)

# 2. 准备接收方的地址
# '192.168.1.103'表示目的ip地址
# 8080表示目的端口
dest_addr = ('192.168.1.103', 8080)  # 注意 是元组，ip是字符串，端口是数字

# 3. 从键盘获取数据
send_data = input("请输入要发送的数据:")

# 4. 发送数据到指定的电脑上的指定程序中
udp_socket.sendto(send_data.encode('utf-8'), dest_addr)

# 5. 关闭套接字
udp_socket.close()
```

### 2. udp网络程序-发送、接收数据

```python
#coding=utf-8

from socket import *

# 1. 创建udp套接字
udp_socket = socket(AF_INET, SOCK_DGRAM)

# 2. 准备接收方的地址
dest_addr = ('192.168.236.129', 8080)

# 3. 从键盘获取数据
send_data = input("请输入要发送的数据:")

# 4. 发送数据到指定的电脑上
udp_socket.sendto(send_data.encode('utf-8'), dest_addr)

# 5. 等待接收对方发送的数据
recv_data = udp_socket.recvfrom(1024)  # 1024表示本次接收的最大字节数

# 6. 显示对方发送的数据
# 接收到的数据recv_data是一个元组
# 第1个元素是对方发送的数据
# 第2个元素是对方的ip和端口
print(recv_data[0].decode('gbk'))
print(recv_data[1])

# 7. 关闭套接字
udp_socket.close()
```

### 3. udp绑定信息

#### 3.1 udp网络程序-端口问题

- 会变的端口号

重新运行多次脚本，然后在“网络调试助手”中，看到的现象如下：

说明：

- 每重新运行一次网络程序，上图中红圈中的数字，不一样的原因在于，这个数字标识这个网络程序，当重新运行时，如果没有确定到底用哪个，系统默认会随机分配
- 记住一点：这个网络程序在运行的过程中，这个就唯一标识这个程序，所以如果其他电脑上的网络程序如果想要向此程序发送数据，那么就需要向这个数字（即端口）标识的程序发送即可

#### 3.2 udp绑定信息

**<1>. 绑定信息**

一般情况下，在一台电脑上运行的网络程序有很多，为了不与其他的网络程序占用同一个端口号，往往在编程中，udp的端口号一般不绑定

但是如果需要做成一个服务器端的程序的话，是需要绑定的，想想看这又是为什么呢？

如果报警电话每天都在变，想必世界就会乱了，所以一般服务性的程序，往往需要一个固定的端口号，这就是所谓的端口绑定

**<2>. 绑定示例**

```python
#coding=utf-8

from socket import *

# 1. 创建套接字
udp_socket = socket(AF_INET, SOCK_DGRAM)

# 2. 绑定本地的相关信息，如果一个网络程序不绑定，则系统会随机分配
local_addr = ('', 7788) #  ip地址和端口号，ip一般不用写，表示本机的任何一个ip
udp_socket.bind(local_addr)

# 3. 等待接收对方发送的数据
recv_data = udp_socket.recvfrom(1024) #  1024表示本次接收的最大字节数

# 4. 显示接收到的数据
print(recv_data[0].decode('gbk'))

# 5. 关闭套接字
udp_socket.close()
```

**<3>. 总结**

- 一个udp网络程序，可以不绑定，此时操作系统会随机进行分配一个端口，如果重新运行此程序端口可能会发生变化
- 一个udp网络程序，也可以绑定信息（ip地址，端口号），如果绑定成功，那么操作系统用这个端口号来进行区别收到的网络数据是否是此进程的

## 四、TCP简介

### 1. TCP介绍

TCP协议，传输控制协议（英语：Transmission Control Protocol，缩写为 TCP），是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。

TCP通信需要经过**创建连接、数据传送、终止连接**三个步骤。

TCP通信模型中，在通信开始之前，一定要先建立相关的链接，才能发送数据，类似于生活中，"打电话""

### 2. TCP特点

#### 2.1 面向连接

通信双方必须先建立连接才能进行数据的传输，双方都必须为该连接分配必要的系统内核资源，以管理连接的状态和连接上的传输。

双方间的数据传输都可以通过这一个连接进行。

完成数据交换后，双方必须断开此连接，以释放系统资源。

这种连接是一对一的，因此TCP不适用于广播的应用程序，基于广播的应用程序请使用UDP协议。

#### 2.2 可靠传输

1）**TCP采用发送应答机制**

TCP发送的每个报文段都必须得到接收方的应答才认为这个TCP报文段传输成功

2）**超时重传**

发送端发出一个报文段之后就启动定时器，如果在定时时间内没有收到应答就重新发送这个报文段。

TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。

3）**错误校验**

TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。

4) **流量控制和阻塞管理**

流量控制用来避免主机发送得过快而使接收方来不及完全收下。

### 3. TCP与UDP的不同点

TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）之间的主要区别如下：

1. 连接类型：TCP 是面向连接的协议，UDP 是无连接的协议。
2. 传输可靠性：TCP 提供可靠的数据传输，具有重传机制、流量控制和拥塞控制，而UDP 不提供这些功能。
3. 数据包大小：TCP 数据包大小有限制，超过限制后必须分段发送；UDP 数据包大小没有限制。
4. 传输性能：UDP 传输性能比 TCP 好，UDP 发送数据速度快，实时性强，适用于对时延要求高的应用场景。
5. 适用范围：TCP 适用于对数据传输质量要求较高的应用场景，如 HTTP、FTP、SSH 等；而 UDP 适用于对实时性、传输效率要求较高的应用场景，如语音、视频、游戏等。

UDP通信模型中，在通信开始之前，不需要建立相关的链接，只需要发送数据即可，类似于生活中，"写信"

TCP通信模型中，在通信开始之前，一定要先建立相关的链接，才能发送数据，类似于生活中，"打电话"

总之，TCP 是一种可靠的传输方式，适用于传输数据要求高可靠性的应用场景，而 UDP 更适合快速传输数据，适用于实时性要求高、传输效率要求高的应用场景。

### 4. tcp客户端

**tcp客户端构建流程**

tcp的客户端要比服务器端简单很多，如果说服务器端是需要自己买手机、查手机卡、设置铃声、等待别人打电话流程的话，那么客户端就只需要找一个电话亭，拿起电话拨打即可，流程要少很多

示例代码：

```python
from socket import *

# 创建socket
tcp_client_socket = socket(AF_INET, SOCK_STREAM)

# 目的信息
server_ip = input("请输入服务器ip:")
server_port = int(input("请输入服务器port:"))

# 链接服务器
tcp_client_socket.connect((server_ip, server_port))

# 提示用户输入数据
send_data = input("请输入要发送的数据：")

tcp_client_socket.send(send_data.encode("gbk"))

# 接收对方发送过来的数据，最大接收1024个字节
recvData = tcp_client_socket.recv(1024)
print('接收到的数据为:', recvData.decode('gbk'))

# 关闭套接字
tcp_client_socket.close()
```

### 5. tcp服务器

#### 5.1 生活中的电话机

如果想让别人能更够打通咱们的电话获取相应服务的话，需要做以下几件事情：

1. 买个手机
2. 插上手机卡
3. 设计手机为正常接听状态（即能够响铃）
4. 静静的等着别人拨打

#### 5.2 tcp服务器

如同上面的电话机过程一样，在程序中，如果想要完成一个tcp服务器的功能，需要的流程如下：

1. socket创建一个套接字
2. bind绑定ip和port
3. listen使套接字变为可以被动链接
4. accept等待客户端的链接
5. recv/send接收发送数据

一个很简单的tcp服务器如下：

```python
from socket import *

# 创建socket
tcp_server_socket = socket(AF_INET, SOCK_STREAM)

# 本地信息
address = ('', 7788)

# 绑定
tcp_server_socket.bind(address)

# 使用socket创建的套接字默认的属性是主动的，使用listen将其变为被动的，这样就可以接收别人的链接了
tcp_server_socket.listen(128)

# 如果有新的客户端来链接服务器，那么就产生一个新的套接字专门为这个客户端服务
# client_socket用来为这个客户端服务
# tcp_server_socket就可以省下来专门等待其他新客户端的链接
client_socket, clientAddr = tcp_server_socket.accept()

# 接收对方发送过来的数据
recv_data = client_socket.recv(1024)  # 接收1024个字节
print('接收到的数据为:', recv_data.decode('gbk'))

# 发送一些数据到客户端
client_socket.send("thank you !".encode('gbk'))

# 关闭为这个客户端服务的套接字，只要关闭了，就意味着为不能再为这个客户端服务了，如果还需要服务，只能再次重新连接
client_socket.close()
```

### 6. tcp注意点

1. tcp服务器一般情况下都需要绑定，否则客户端找不到这个服务器
2. tcp客户端一般不绑定，因为是主动链接服务器，所以只要确定好服务器的ip、port等信息就好，本地客户端可以随机
3. tcp服务器中通过listen可以将socket创建出来的主动套接字变为被动的，这是做tcp服务器时必须要做的
4. 当客户端需要链接服务器时，就需要使用connect进行链接，udp是不需要链接的而是直接发送，但是tcp必须先链接，只有链接成功才能通信
5. 当一个tcp客户端连接服务器时，服务器端会有1个新的套接字，这个套接字用来标记这个客户端，单独为这个客户端服务
6. listen后的套接字是被动套接字，用来接收新的客户端的链接请求的，而accept返回的新套接字是标记这个新客户端的
7. 关闭listen后的套接字意味着被动套接字关闭了，会导致新的客户端不能够链接服务器，但是之前已经链接成功的客户端正常通信。
8. 关闭accept返回的套接字意味着这个客户端已经服务完毕
9. 当客户端的套接字调用close后，服务器端会recv解堵塞，并且返回的长度为0，因此服务器可以通过返回数据的长度来区别客户端是否已经下线

### 7. tcp的3次握手、4次挥手

TCP是一种可靠的面向连接的协议，用于在计算机之间传输数据。TCP连接的建立和关闭分别需要使用三次握手和四次挥手。

**三次握手**

在建立TCP连接时，客户端和服务器之间需要进行三次握手：

1. 客户端发送一个SYN（同步）标志位设置为1的包，其中还包含一个随机的序列号（seq）值，表示客户端准备向服务器发送数据。
2. 服务器接收到SYN包后，返回一个SYN/ACK（同步/确认）标志位设置为1的包，其中包含服务器的随机序列号（seq）和客户端序列号值加1（ack）。
3. 客户端收到SYN/ACK包后，发送一个ACK（确认）标志位设置为1的包，其中包含客户端序列号值加1（seq）和服务器序列号值加1（ack）。

这样，客户端和服务器就建立了一个TCP连接，可以开始互相传输数据。

**四次挥手**

在关闭TCP连接时，客户端和服务器之间需要进行四次挥手：

1. 客户端发送一个FIN（结束）标志位设置为1的包，表示客户端不再向服务器发送数据。
2. 服务器收到FIN包后，发送一个ACK标志位设置为1的包，表示服务器已经收到了客户端的FIN包。
3. 服务器发送一个FIN标志位设置为1的包，表示服务器也不再向客户端发送数据。
4. 客户端收到FIN包后，发送一个ACK标志位设置为1的包，表示客户端已经收到了服务器的FIN包。

这样，客户端和服务器就完成了TCP连接的关闭。注意，在四次挥手中，客户端最后发送的ACK包并不表示已经关闭了连接，只是告诉服务器客户端已经收到了服务器的FIN包。只有当服务器收到了客户端的ACK包后，才能确认TCP连接已经关闭。

### 8. tcp长连接和短连接

TCP在真正的读写操作之前，server与client之间必须建立一个连接，

当读写操作完成后，双方不再需要这个连接时它们可以释放这个连接，

连接的建立通过三次握手，释放则需要四次握手，

所以说每个连接的建立都是需要资源消耗和时间消耗的。

#### 8.1 TCP通信的整个过程，如下图:

![20210206152937](/Users/zhougaofeng/Desktop/Salute_系列/Salute_Python/img/2.png)

#### 8.2 TCP短连接

模拟一种TCP短连接的情况:

1. client 向 server 发起连接请求
2. server 接到请求，双方建立连接
3. client 向 server 发送消息
4. server 回应 client
5. 一次读写完成，此时双方任何一个都可以发起 close 操作

在步骤5中，一般都是 client 先发起 close 操作。当然也不排除有特殊的情况。

从上面的描述看，短连接一般只会在 client/server 间传递一次读写操作！

#### 8.3 TCP长连接

再模拟一种长连接的情况:

1. client 向 server 发起连接
2. server 接到请求，双方建立连接
3. client 向 server 发送消息
4. server 回应 client
5. 一次读写完成，连接不关闭
6. 后续读写操作...
7. 长时间操作之后client发起关闭请求

#### 8.4 TCP长/短连接操作过程

**短连接的操作步骤是：**

建立连接——数据传输——关闭连接...建立连接——数据传输——关闭连接

**长连接的操作步骤是：**

建立连接——数据传输...（保持连接）...数据传输——关闭连接

#### 8.5  TCP长/短连接的优点和缺点

TCP长连接和短连接的优缺点如下：

**长连接**

优点：

1. 减少了TCP建立和关闭的时间开销，提高了性能。
2. 减少了网络带宽的消耗，因为建立连接的时候会消耗一定的带宽资源。
3. 适合于频繁的数据通信，减少了重复建立连接的开销。
4. 在某些场景下可以减轻服务器的压力，因为在长连接下，客户端和服务器之间可以通过保持连接的方式来减轻服务器的负担。
5. 支持HTTP/1.1的持久连接和HTTP/2的流复用，可以显著提升网络传输效率。

缺点：

1. 可能会造成资源浪费，因为长连接会占用一定的系统资源，如果没有及时释放连接，可能会导致系统资源浪费。
2. 对服务器的并发处理能力有一定的限制，因为长连接会占用一定的资源，如果连接数过多，可能会对服务器的并发处理能力造成一定的压力。
3. 可能会因为连接的过程中网络异常或者其他原因而导致连接断开，需要进行重连。

**短连接**

优点：

1. 可以及时释放资源，减少了系统资源的占用。
2. 适合于一次性传输少量数据的场景。
3. 不会对服务器的并发处理能力造成过大的压力。

缺点：

1. 需要频繁建立和关闭连接，会造成一定的性能开销和网络带宽的消耗。
2. 不支持HTTP/1.1的持久连接和HTTP/2的流复用，传输效率不如长连接。
3. 在某些场景下可能会影响服务器的性能，因为频繁的建立和关闭连接会占用一定的系统资源。

#### 8.6 TCP长/短连接的应用场景

TCP长/短连接的应用场景取决于网络传输数据的要求和性能需求。

长连接：适用于需要频繁传输数据的场景，例如聊天应用、在线游戏、视频流等。使用长连接能够提高传输效率和减少连接的建立和关闭次数，降低网络负载和资源消耗，提高用户的体验。

短连接：适用于传输数据量较小，传输结束后就可以断开连接的场景，例如网页浏览、文件下载等。使用短连接可以避免因长时间没有活动而占用资源而不必要的消耗，节省网络带宽，提高服务器的处理能力。

总的来说，长连接适用于需要频繁发送数据的场景，短连接适用于只需要定期传输数据的场景。需要根据实际情况进行选择，以达到最优的效果。

### 9. tcp-ip简介

作为新时代标杆的我们，已经离不开手机、离不开网络，对于互联网大家可能耳熟能详，但是计算机网络的出现比互联网要早很多

#### 9.1 什么是协议

有的说英语，有的说中文，有的说德语，说同一种语言的人可以交流，不同的语言之间就不行了

为了解决不同种族人之间的语言沟通障碍，现规定国际通用语言是英语，这就是一个规定，这就是协议

#### 9.2 计算机网络沟通用什么

现在的生活中，不同的计算机只需要能够联网（有线无线都可以）那么就可以相互进行传递数据

那么不同种类之间的计算机到底是怎么进行数据传递的呢？

就像说不同语言的人沟通一样，只要有一种大家都认可都遵守的协议即可，那么这个计算机都遵守的网络通信协议叫做`TCP/IP协议`

### 10. TCP/IP协议(族)

早期的计算机网络，都是由各厂商自己规定一套协议，IBM、Apple和Microsoft都有各自的网络协议，互不兼容

为了把全世界的所有不同类型的计算机都连接起来，就必须规定一套全球通用的协议，为了实现互联网这个目标，互联网协议族（Internet Protocol Suite）就是通用协议标准。

因为互联网协议包含了上百种协议标准，但是最重要的两个协议是TCP和IP协议，所以，大家把互联网的协议简称TCP/IP协议(族)
